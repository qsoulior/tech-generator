// Code generated by ogen, DO NOT EDIT.

package api

import (
	"context"
	"net/http"

	"github.com/go-faster/errors"
	ht "github.com/ogen-go/ogen/http"
	"github.com/ogen-go/ogen/middleware"
	"github.com/ogen-go/ogen/ogenerrors"
)

type codeRecorder struct {
	http.ResponseWriter
	status int
}

func (c *codeRecorder) WriteHeader(status int) {
	c.status = status
	c.ResponseWriter.WriteHeader(status)
}

func (c *codeRecorder) Unwrap() http.ResponseWriter {
	return c.ResponseWriter
}

func recordError(string, error) {}

// handleProjectCreateRequest handles projectCreate operation.
//
// Создать проект.
//
// POST /project/create
func (s *Server) handleProjectCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectCreateOperation,
			ID:   "projectCreate",
		}
	)
	params, err := decodeProjectCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeProjectCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response ProjectCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectCreateOperation,
			OperationSummary: "Создать проект",
			OperationID:      "projectCreate",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = *ProjectCreateRequest
			Params   = ProjectCreateParams
			Response = ProjectCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectDeleteByIDRequest handles projectDeleteByID operation.
//
// Удалить проект.
//
// DELETE /project/delete/{projectID}
func (s *Server) handleProjectDeleteByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectDeleteByIDOperation,
			ID:   "projectDeleteByID",
		}
	)
	params, err := decodeProjectDeleteByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectDeleteByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectDeleteByIDOperation,
			OperationSummary: "Удалить проект",
			OperationID:      "projectDeleteByID",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "projectID",
					In:   "path",
				}: params.ProjectID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectDeleteByIDParams
			Response = ProjectDeleteByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectDeleteByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectDeleteByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectDeleteByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectDeleteByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleProjectListRequest handles projectList operation.
//
// Получить список проектов.
//
// GET /project/list
func (s *Server) handleProjectListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: ProjectListOperation,
			ID:   "projectList",
		}
	)
	params, err := decodeProjectListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response ProjectListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    ProjectListOperation,
			OperationSummary: "Получить список проектов",
			OperationID:      "projectList",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "size",
					In:   "query",
				}: params.Size,
				{
					Name: "sorting",
					In:   "query",
				}: params.Sorting,
				{
					Name: "projectName",
					In:   "query",
				}: params.ProjectName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = ProjectListParams
			Response = ProjectListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackProjectListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.ProjectList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.ProjectList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeProjectListResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTaskCreateRequest handles taskCreate operation.
//
// Создать задачу генерации.
//
// POST /task/create
func (s *Server) handleTaskCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TaskCreateOperation,
			ID:   "taskCreate",
		}
	)
	params, err := decodeTaskCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTaskCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TaskCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TaskCreateOperation,
			OperationSummary: "Создать задачу генерации",
			OperationID:      "taskCreate",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = *TaskCreateRequest
			Params   = TaskCreateParams
			Response = TaskCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTaskCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TaskCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TaskCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTaskCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTaskGetByIDRequest handles taskGetByID operation.
//
// Получить задачу генерации по ID.
//
// GET /task/get/{taskID}
func (s *Server) handleTaskGetByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TaskGetByIDOperation,
			ID:   "taskGetByID",
		}
	)
	params, err := decodeTaskGetByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TaskGetByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TaskGetByIDOperation,
			OperationSummary: "Получить задачу генерации по ID",
			OperationID:      "taskGetByID",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "taskID",
					In:   "path",
				}: params.TaskID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TaskGetByIDParams
			Response = TaskGetByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTaskGetByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TaskGetByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TaskGetByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTaskGetByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTaskListRequest handles taskList operation.
//
// Получить список задач генерации.
//
// GET /task/list
func (s *Server) handleTaskListRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TaskListOperation,
			ID:   "taskList",
		}
	)
	params, err := decodeTaskListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TaskListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TaskListOperation,
			OperationSummary: "Получить список задач генерации",
			OperationID:      "taskList",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "size",
					In:   "query",
				}: params.Size,
				{
					Name: "sorting",
					In:   "query",
				}: params.Sorting,
				{
					Name: "templateID",
					In:   "query",
				}: params.TemplateID,
				{
					Name: "creatorID",
					In:   "query",
				}: params.CreatorID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TaskListParams
			Response = TaskListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTaskListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TaskList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TaskList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTaskListResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTemplateCreateRequest handles templateCreate operation.
//
// Создать шаблон.
//
// POST /template/create
func (s *Server) handleTemplateCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TemplateCreateOperation,
			ID:   "templateCreate",
		}
	)
	params, err := decodeTemplateCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeTemplateCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response TemplateCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TemplateCreateOperation,
			OperationSummary: "Создать шаблон",
			OperationID:      "templateCreate",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = *TemplateCreateRequest
			Params   = TemplateCreateParams
			Response = TemplateCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTemplateCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TemplateCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TemplateCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTemplateCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTemplateDeleteByIDRequest handles templateDeleteByID operation.
//
// Удалить шаблон.
//
// DELETE /template/delete/{templateID}
func (s *Server) handleTemplateDeleteByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TemplateDeleteByIDOperation,
			ID:   "templateDeleteByID",
		}
	)
	params, err := decodeTemplateDeleteByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TemplateDeleteByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TemplateDeleteByIDOperation,
			OperationSummary: "Удалить шаблон",
			OperationID:      "templateDeleteByID",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "templateID",
					In:   "path",
				}: params.TemplateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TemplateDeleteByIDParams
			Response = TemplateDeleteByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTemplateDeleteByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TemplateDeleteByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TemplateDeleteByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTemplateDeleteByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTemplateGetByIDRequest handles templateGetByID operation.
//
// Получить шаблон по ID.
//
// GET /template/get/{templateID}
func (s *Server) handleTemplateGetByIDRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TemplateGetByIDOperation,
			ID:   "templateGetByID",
		}
	)
	params, err := decodeTemplateGetByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TemplateGetByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TemplateGetByIDOperation,
			OperationSummary: "Получить шаблон по ID",
			OperationID:      "templateGetByID",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "templateID",
					In:   "path",
				}: params.TemplateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TemplateGetByIDParams
			Response = TemplateGetByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTemplateGetByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TemplateGetByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TemplateGetByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTemplateGetByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleTemplateListRequest handles templateList operation.
//
// Получить список шаблонов в проекте.
//
// GET /template/list/{projectID}
func (s *Server) handleTemplateListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: TemplateListOperation,
			ID:   "templateList",
		}
	)
	params, err := decodeTemplateListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response TemplateListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    TemplateListOperation,
			OperationSummary: "Получить список шаблонов в проекте",
			OperationID:      "templateList",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "projectID",
					In:   "path",
				}: params.ProjectID,
				{
					Name: "page",
					In:   "query",
				}: params.Page,
				{
					Name: "size",
					In:   "query",
				}: params.Size,
				{
					Name: "sorting",
					In:   "query",
				}: params.Sorting,
				{
					Name: "templateName",
					In:   "query",
				}: params.TemplateName,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = TemplateListParams
			Response = TemplateListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackTemplateListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.TemplateList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.TemplateList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeTemplateListResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUserCreateRequest handles userCreate operation.
//
// Создать пользователя.
//
// POST /user/create
func (s *Server) handleUserCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UserCreateOperation,
			ID:   "userCreate",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUserCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UserCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UserCreateOperation,
			OperationSummary: "Создать пользователя",
			OperationID:      "userCreate",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UserCreateRequest
			Params   = struct{}
			Response = UserCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserCreate(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserCreate(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUserGetByIDRequest handles userGetByID operation.
//
// Получить пользователя.
//
// GET /user/get
func (s *Server) handleUserGetByIDRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UserGetByIDOperation,
			ID:   "userGetByID",
		}
	)
	params, err := decodeUserGetByIDParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response UserGetByIDRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UserGetByIDOperation,
			OperationSummary: "Получить пользователя",
			OperationID:      "userGetByID",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = UserGetByIDParams
			Response = UserGetByIDRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackUserGetByIDParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserGetByID(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserGetByID(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserGetByIDResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleUserTokenCreateRequest handles userTokenCreate operation.
//
// Создать токен пользователя.
//
// POST /user/token/create
func (s *Server) handleUserTokenCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: UserTokenCreateOperation,
			ID:   "userTokenCreate",
		}
	)

	var rawBody []byte
	request, rawBody, close, err := s.decodeUserTokenCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response UserTokenCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    UserTokenCreateOperation,
			OperationSummary: "Создать токен пользователя",
			OperationID:      "userTokenCreate",
			Body:             request,
			RawBody:          rawBody,
			Params:           middleware.Parameters{},
			Raw:              r,
		}

		type (
			Request  = *UserTokenCreateRequest
			Params   = struct{}
			Response = UserTokenCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			nil,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.UserTokenCreate(ctx, request)
				return response, err
			},
		)
	} else {
		response, err = s.h.UserTokenCreate(ctx, request)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeUserTokenCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleVersionCreateRequest handles versionCreate operation.
//
// Создать версию шаблона.
//
// POST /version/create
func (s *Server) handleVersionCreateRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: VersionCreateOperation,
			ID:   "versionCreate",
		}
	)
	params, err := decodeVersionCreateParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeVersionCreateRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response VersionCreateRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    VersionCreateOperation,
			OperationSummary: "Создать версию шаблона",
			OperationID:      "versionCreate",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = *VersionCreateRequest
			Params   = VersionCreateParams
			Response = VersionCreateRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackVersionCreateParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.VersionCreate(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.VersionCreate(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeVersionCreateResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleVersionCreateFromRequest handles versionCreateFrom operation.
//
// Создать версию шаблона из другой версии.
//
// POST /version/create_from
func (s *Server) handleVersionCreateFromRequest(args [0]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: VersionCreateFromOperation,
			ID:   "versionCreateFrom",
		}
	)
	params, err := decodeVersionCreateFromParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte
	request, rawBody, close, err := s.decodeVersionCreateFromRequest(r)
	if err != nil {
		err = &ogenerrors.DecodeRequestError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeRequest", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}
	defer func() {
		if err := close(); err != nil {
			recordError("CloseRequest", err)
		}
	}()

	var response VersionCreateFromRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    VersionCreateFromOperation,
			OperationSummary: "Создать версию шаблона из другой версии",
			OperationID:      "versionCreateFrom",
			Body:             request,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
			},
			Raw: r,
		}

		type (
			Request  = *VersionCreateFromRequest
			Params   = VersionCreateFromParams
			Response = VersionCreateFromRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackVersionCreateFromParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.VersionCreateFrom(ctx, request, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.VersionCreateFrom(ctx, request, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeVersionCreateFromResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}

// handleVersionListRequest handles versionList operation.
//
// Получить список шаблонов в проекте.
//
// GET /version/list/{templateID}
func (s *Server) handleVersionListRequest(args [1]string, argsEscaped bool, w http.ResponseWriter, r *http.Request) {
	statusWriter := &codeRecorder{ResponseWriter: w}
	w = statusWriter
	ctx := r.Context()

	var (
		err          error
		opErrContext = ogenerrors.OperationContext{
			Name: VersionListOperation,
			ID:   "versionList",
		}
	)
	params, err := decodeVersionListParams(args, argsEscaped, r)
	if err != nil {
		err = &ogenerrors.DecodeParamsError{
			OperationContext: opErrContext,
			Err:              err,
		}
		defer recordError("DecodeParams", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	var rawBody []byte

	var response VersionListRes
	if m := s.cfg.Middleware; m != nil {
		mreq := middleware.Request{
			Context:          ctx,
			OperationName:    VersionListOperation,
			OperationSummary: "Получить список шаблонов в проекте",
			OperationID:      "versionList",
			Body:             nil,
			RawBody:          rawBody,
			Params: middleware.Parameters{
				{
					Name: "X-User-Id",
					In:   "header",
				}: params.XUserID,
				{
					Name: "templateID",
					In:   "path",
				}: params.TemplateID,
			},
			Raw: r,
		}

		type (
			Request  = struct{}
			Params   = VersionListParams
			Response = VersionListRes
		)
		response, err = middleware.HookMiddleware[
			Request,
			Params,
			Response,
		](
			m,
			mreq,
			unpackVersionListParams,
			func(ctx context.Context, request Request, params Params) (response Response, err error) {
				response, err = s.h.VersionList(ctx, params)
				return response, err
			},
		)
	} else {
		response, err = s.h.VersionList(ctx, params)
	}
	if err != nil {
		defer recordError("Internal", err)
		s.cfg.ErrorHandler(ctx, w, r, err)
		return
	}

	if err := encodeVersionListResponse(response, w); err != nil {
		defer recordError("EncodeResponse", err)
		if !errors.Is(err, ht.ErrInternalServerErrorResponse) {
			s.cfg.ErrorHandler(ctx, w, r, err)
		}
		return
	}
}
